Name: Eisha Yadav

| Date  |       Time       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Update |
|:------|:----------------:|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| 10/13 |   5:15-6:30 pm   |                                                                                                                                                                                                                                                                       Began initial thought process on how to tackle the issue. I was only able to determine certain edge cases, such as when the sequence is simply too short to contain the string, and when the sequence/string itself is null. However, I wasn't able to figure out a non compare every value solution to the problem- and with chromosome 22 - it would take such a long time and never entirely complete. Most of this time was just spent ideating, but i wasn't able to surpass the char by char comparision issue. (length of sequence x length of str time complexity) |
| 10/15 | 10:50 - 11:20 am |                                                                                                                                                                                                                                                                                                                                                                      Tried to anylze how to specifically solve the runtime issue, and realize that its inevitable to cover every single element in the sequence (because if you skip a char the sequence couldn't be fully aligned). Since this is  the case, the only way to reduce time complexity is not have the entire sequence length be iterated over-- which I have yet to figure out how to do. I spent much of this time discussing with classmates what potential solutions could be. |
| 10/15 | 11:20 - 11:50 am |                                      Continued to talk with my classmates regarding solutions to the comparision issue. One idea we had was assigning a numerical value to the entirety of the str as a whole, and then comparing that number with each segment of the sequence could work. However, the time complexity of calculating a unique number likley will take so long that the whole purpose of the algorithm goes down the drain. We also thought of creating some sort of prefix table where initial segments of the str would be tracked meaning that you don't have to go fully back when reaching a mistake, however, again, I think this will still lead to the same amount of comparisions because at the end of the day you are comparing prefixes not strings. So... after this session i have reached back where I started. |
| 10/16 |   3:50-4:15 pm   | I decided to simply start coding the long solution (literally compare everything) and implemented a simple for loop solution comparing str length segments of seq with str. However, when looking up methods to compare segments of a large string with a seperate string I found the compare region section-- which I am not sure has a faster runtime (i dont think it does) and is likley just a fancy way of writing .equals without having to substring, so I still need to work further to figure out an efficient way to implement the solution. However, I do now have a functioning solution (albeit with an almost 3 second runtime) so I have something to work off of. I am now just going to add some comments and the update my worklog and submit this initial version, while I continue to brainstorm a more efficient solution. |
| 10/17 |   4:50-5:20 pm   |                                                                                                                                                                                                                                                                                                                                                       Began coding my radix 256 solution based upon the slides, and the explanation shared in class. I began by implementing my hash function, which took me a good amount of time to comprehend. This was mostly because I forgot how to compute powers using java, and also kept running into integer overflow errors. I then used the big integer class, which allowed me to have more numerical space to work with, however-- with this time I was only able to implement the hash function. |
| 10/17 |   5:20-6:00 pm   |                                                                                                                                                                                                                                                                                                                                                                                                                                                        I realized that there was an error in my previously constructed hash function, where the p value I was using was not ideal-- and I was also somehow ending up with overflow and negative hashes. I spent some time debugging and realized that the power functions and multipliers I was using were wrong. Hence, the hashes were growing at much higher rates than they shold have been. |
| 10/18 |   7:30-7:50 pm   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                I began by continuing to fix my hash function, and then spent a lot of time conceptualizing how best to implement the robin karp algorithm that uses the old hash. I tried a couple of different methods, and soon was able to properly copy the formula displayed on the slides. |
| 10/18 |   7:50-8:20 pm   |                                                                                                                                                                                                                                                                                                                                                                                                    After implementing the robin karp algorithm, I ran my test cases and realized all of my values were slightly off. This was because I was shifting one index over too many, resulting in many errors. Once I fixed my indexing error, my test cases were passed (albeit slower than I expected them to be passed). However, I tried to import test tricky.. and realized that it was off and incorrect, bringing me back to the drawing board. |
| 10/23 |   4:15-4:45 pm   |                                                                                                                                                                                                                                              In class I heard the relevence of using radix 4 rather than radix 256, and since I have to re-do my code because of the new test case anyway (because I feel there are some structural changes that need to be made). Hence, I decided to restructure my algorithm to be more efficient and work faster by utilizing radix four. Talking with my classmates, they also suggested using 2 bit shifting, because radix four means that EVERY value can be represented with only two bits, and to shift the hash, the operator << can be used to save time and still implement the same functionality. |
| 10/23 |  4:45- 5:20 pm   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         I began implementing the pre-commented radix four solution, and realized that I could just use a switch case to encode each hash, with certain letters corresponding to certain numerical codes. There could be a more efficient way to do this, like simply using the character ascii itself, but that would be difficult to translate into radix four. |
| 10/25 |  5:15 - 5:50 pm  |                                                                                                                                                      After implementing that functionality, I thought about how to compute rolling hashes in this scenario. I realized that I didn't have to deal with the previous complex math, simply because these were aldready encoded as the two bit values. The two bit encodings resulted in different chains/sequences for different orderings of letters-- and to compute the "rolling hash" I could just shift the two previous bits two slots to the left, and then add/combine the additional bits to the end of the hash. This then resulted in my overall STR hash. I then repeated this process to create my hash of the sequence itself, and check the calculated hashes against the STR hash. |
| 10/25 |  5:50 - 6:20 pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               I now needed to code in my masking function, that turns specfic bits on and gets rid of the "useless" leading bits of the previous hash. To do so, I utilized bit masking, which we talked about in class. Here, a series of bits that are just 1111 turn on the bits that need to be kept, while the initial bits are turned off. |
| 10/28 | 9:45 - 10:30 pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                      I then proceeded to test and make sure all of my code worked well together. I realized that I was re-setting my max-repeats each time, so I shifted my initialization outside of one of my major loops. I then realized that the hash was incrementing too many times (almost recursively repeating) and then realized I forgot to properly increment i in the loop, so I added that functionality as well. |
| 10/28 | 10:30 - 11:00 pm |                                                                                                                                                                                                                                                                                                                                                                                                                                                 I finally got working code, which passed all the test cases, so I began cleaning up useless/redundant lines, and writing comments. I realized I still had a power function from a previous iteration that I no longer needed, so I removed that. I also made sure I used consistent formatting for all of the loops, as sometimes I don't use curly braces and line spacing, but sometimes I do. |
| 10/29 |  8:05 - 8:35 am   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       I finished updating my work log, added some additional comments, and checked that I still passed my tests one final time.  |




